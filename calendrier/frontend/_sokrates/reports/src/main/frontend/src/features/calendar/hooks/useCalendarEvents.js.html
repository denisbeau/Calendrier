<html>
<head>
    <title>frontend/src/features/calendar/hooks/useCalendarEvents.js</title>
    <style type="text/css" media="screen">
        #editor {
            position: absolute;
            top: 40px;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">frontend/src/features/calendar/hooks/useCalendarEvents.js (<b>136</b> lines of code) (<a href="useCalendarEvents.js">raw</a>):</h3>
<div id="editor">// src/features/calendar/hooks/useCalendarEvents.js
import { useState, useMemo } from &quot;react&quot;;
import { getCurrentDateTime, getOneHourFromNow, formatDateTimeLocal } from &quot;../../../utils/dateUtils&quot;;
import { DEFAULT_EVENT_COLOR, DEFAULT_CATEGORY_NAME } from &quot;../../../utils/constants&quot;;

export function useCalendarEvents() {
  const [events, setEvents] = useState([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errors, setErrors] = useState({});

  // Basic id generator for demo purposes
  const nextId = useMemo(() =&gt; {
    return () =&gt; Math.max(0, ...events.map((e) =&gt; e.id || 0)) + 1;
  }, [events]);

  function validateEvent(event) {
    const newErrors = {};
    
    if (!event.title.trim()) {
      newErrors.title = &quot;Event title is required&quot;;
    }
    
    if (!event.start) {
      newErrors.start = &quot;Start time is required&quot;;
    }
    
    if (!event.end) {
      newErrors.end = &quot;End time is required&quot;;
    }
    
    if (event.start &amp;&amp; event.end) {
      const startDate = new Date(event.start);
      const endDate = new Date(event.end);
      
      if (isNaN(startDate.getTime())) {
        newErrors.start = &quot;Invalid start date&quot;;
      }
      
      if (isNaN(endDate.getTime())) {
        newErrors.end = &quot;Invalid end date&quot;;
      }
      
      if (startDate &gt;= endDate) {
        newErrors.end = &quot;End time must be after start time&quot;;
      }
    }
    
    return newErrors;
  }

  async function handleFormSubmit(formEvent, isEditing, editingEventId, onSuccess) {
    if (isSubmitting) return; // Prevent double submission
    
    setIsSubmitting(true);
    setErrors({});

    try {
      const validationErrors = validateEvent(formEvent);
      
      if (Object.keys(validationErrors).length &gt; 0) {
        setErrors(validationErrors);
        return;
      }

      const startDate = new Date(formEvent.start);
      const endDate = new Date(formEvent.end);

      // Helper to create event object
      const createEventObject = (id) =&gt; ({
        id,
        title: formEvent.title.trim(),
        start: startDate,
        end: endDate,
        color: formEvent.color || DEFAULT_EVENT_COLOR,
        categoryName: formEvent.categoryName?.trim() || DEFAULT_CATEGORY_NAME,
      });

      if (isEditing) {
        // Update existing event
        const updatedEvent = createEventObject(editingEventId);
        setEvents(prev =&gt; prev.map(event =&gt; 
          event.id === editingEventId ? updatedEvent : event
        ));
        
        onSuccess?.();
      } else {
        // Create new event
        const newEventObj = createEventObject(nextId());

        setEvents(prev =&gt; [...prev, newEventObj]);
        onSuccess?.();
      }
      
    } catch (error) {
      console.error(&quot;Error saving event:&quot;, error);
      setErrors({ general: &quot;Failed to save event. Please try again.&quot; });
    } finally {
      setIsSubmitting(false);
    }
  }

  function handleSelectEvent(event, onSelect) {
    // Populate the form with the event data for editing
    const eventData = {
      title: event.title,
      start: formatDateTimeLocal(event.start),
      end: formatDateTimeLocal(event.end),
      color: event.color || DEFAULT_EVENT_COLOR,
      categoryName: event.categoryName || DEFAULT_CATEGORY_NAME
    };
    onSelect?.(eventData, event.id);
    setErrors({});
  }

  function handleDeleteEvent(editingEventId, onSuccess) {
    if (window.confirm(&quot;Are you sure you want to delete this event?&quot;)) {
      setEvents(prev =&gt; prev.filter(event =&gt; event.id !== editingEventId));
      onSuccess?.();
    }
  }

  function handleSelectSlot(slotInfo, defaultColor, defaultCategoryName) {
    try {
      // Format the selected time range for display
      const startTime = slotInfo.start.toLocaleString();
      const endTime = slotInfo.end.toLocaleString();
      
      const title = prompt(`Enter event title for:\n${startTime} - ${endTime}`);
      if (!title || !title.trim()) return;
      
      const newEventObj = {
        id: nextId(),
        title: title.trim(),
        start: slotInfo.start,
        end: slotInfo.end,
        color: defaultColor || DEFAULT_EVENT_COLOR,
        categoryName: defaultCategoryName?.trim() || DEFAULT_CATEGORY_NAME,
      };
      
      setEvents(prev =&gt; [...prev, newEventObj]);
      
      // Show success message
      console.log(`Event &quot;${title.trim()}&quot; created successfully!`);
      
    } catch (error) {
      console.error(&quot;Error creating event from slot:&quot;, error);
      console.error(&quot;SlotInfo:&quot;, slotInfo);
      console.error(&quot;Events array:&quot;, events);
      alert(&quot;Failed to create event. Please try again.&quot;);
    }
  }

  function getInitialFormState() {
    return {
      title: &quot;&quot;,
      start: getCurrentDateTime(),
      end: getOneHourFromNow(),
      color: DEFAULT_EVENT_COLOR,
      categoryName: DEFAULT_CATEGORY_NAME,
    };
  }

  return {
    events,
    setEvents,
    isSubmitting,
    errors,
    setErrors,
    handleFormSubmit,
    handleSelectEvent,
    handleDeleteEvent,
    handleSelectSlot,
    getInitialFormState,
  };
}

</div>
<script src="https://www.zeljkoobrenovic.com/tools/common/lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
    editor.session.setMode("ace/mode/javascript");
    editor.setTheme("ace/theme/xcode");
    editor.setReadOnly(true);
    editor.setOption("wrap", true);
    editor.setPrintMarginColumn(120);
</script>
</body>
