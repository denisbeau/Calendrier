<html>
<head>
    <title>export function useCalendarEvents()</title>
    <link rel="stylesheet" charset="UTF-8" href="https://d2bb1mtyn3kglb.cloudfront.net/lib/highlight/styles/docco.min.css">
    <script charset="UTF-8" type="application/javascript" src="https://d2bb1mtyn3kglb.cloudfront.net/lib/highlight/highlight.min.js"></script>
</head>
<body style="font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif">
<h3 style="margin-bottom: 0">export function useCalendarEvents()</h3>
<p style="margin-top: 4px">in <i>frontend/src/features/calendar/hooks/useCalendarEvents.js [6:180]</i></p>
<ul>
    <li><b>1</b> lines of code</li>
    <li><b>1</b> McCabe index (conditional complexity)</li>
</ul>
<pre>
<code class="js">
export function useCalendarEvents() {
  const [events, setEvents] = useState([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errors, setErrors] = useState({});

  // Basic id generator for demo purposes
  const nextId = useMemo(() =&gt; {
    return () =&gt; Math.max(0, ...events.map((e) =&gt; e.id || 0)) + 1;
  }, [events]);

  function validateEvent(event) {
    const newErrors = {};
    
    if (!event.title.trim()) {
      newErrors.title = &quot;Event title is required&quot;;
    }
    
    if (!event.start) {
      newErrors.start = &quot;Start time is required&quot;;
    }
    
    if (!event.end) {
      newErrors.end = &quot;End time is required&quot;;
    }
    
    if (event.start &amp;&amp; event.end) {
      const startDate = new Date(event.start);
      const endDate = new Date(event.end);
      
      if (isNaN(startDate.getTime())) {
        newErrors.start = &quot;Invalid start date&quot;;
      }
      
      if (isNaN(endDate.getTime())) {
        newErrors.end = &quot;Invalid end date&quot;;
      }
      
      if (startDate &gt;= endDate) {
        newErrors.end = &quot;End time must be after start time&quot;;
      }
    }
    
    return newErrors;
  }

  async function handleFormSubmit(formEvent, isEditing, editingEventId, onSuccess) {
    if (isSubmitting) return; // Prevent double submission
    
    setIsSubmitting(true);
    setErrors({});

    try {
      const validationErrors = validateEvent(formEvent);
      
      if (Object.keys(validationErrors).length &gt; 0) {
        setErrors(validationErrors);
        return;
      }

      const startDate = new Date(formEvent.start);
      const endDate = new Date(formEvent.end);

      if (isEditing) {
        // Update existing event
        const updatedEvent = {
          id: editingEventId,
          title: formEvent.title.trim(),
          start: startDate,
          end: endDate,
          color: formEvent.color || DEFAULT_EVENT_COLOR,
          categoryName: formEvent.categoryName?.trim() || DEFAULT_CATEGORY_NAME,
        };

        setEvents(prev =&gt; prev.map(event =&gt; 
          event.id === editingEventId ? updatedEvent : event
        ));
        
        onSuccess?.();
      } else {
        // Create new event
        const newEventObj = {
          id: nextId(),
          title: formEvent.title.trim(),
          start: startDate,
          end: endDate,
          color: formEvent.color || DEFAULT_EVENT_COLOR,
          categoryName: formEvent.categoryName?.trim() || DEFAULT_CATEGORY_NAME,
        };

        setEvents(prev =&gt; [...prev, newEventObj]);
        onSuccess?.();
      }
      
    } catch (error) {
      console.error(&quot;Error saving event:&quot;, error);
      setErrors({ general: &quot;Failed to save event. Please try again.&quot; });
    } finally {
      setIsSubmitting(false);
    }
  }

  function handleSelectEvent(event, onSelect) {
    // Populate the form with the event data for editing
    const eventData = {
      title: event.title,
      start: formatDateTimeLocal(event.start),
      end: formatDateTimeLocal(event.end),
      color: event.color || DEFAULT_EVENT_COLOR,
      categoryName: event.categoryName || DEFAULT_CATEGORY_NAME
    };
    onSelect?.(eventData, event.id);
    setErrors({});
  }

  function handleDeleteEvent(editingEventId, onSuccess) {
    if (window.confirm(&quot;Are you sure you want to delete this event?&quot;)) {
      setEvents(prev =&gt; prev.filter(event =&gt; event.id !== editingEventId));
      onSuccess?.();
    }
  }

  function handleSelectSlot(slotInfo, defaultColor, defaultCategoryName) {
    try {
      // Format the selected time range for display
      const startTime = slotInfo.start.toLocaleString();
      const endTime = slotInfo.end.toLocaleString();
      
      const title = prompt(`Enter event title for:\n${startTime} - ${endTime}`);
      if (!title || !title.trim()) return;
      
      const newEventObj = {
        id: nextId(),
        title: title.trim(),
        start: slotInfo.start,
        end: slotInfo.end,
        color: defaultColor || DEFAULT_EVENT_COLOR,
        categoryName: defaultCategoryName?.trim() || DEFAULT_CATEGORY_NAME,
      };
      
      setEvents(prev =&gt; [...prev, newEventObj]);
      
      // Show success message
      console.log(`Event &quot;${title.trim()}&quot; created successfully!`);
      
    } catch (error) {
      console.error(&quot;Error creating event from slot:&quot;, error);
      console.error(&quot;SlotInfo:&quot;, slotInfo);
      console.error(&quot;Events array:&quot;, events);
      alert(&quot;Failed to create event. Please try again.&quot;);
    }
  }

  function getInitialFormState() {
    return {
      title: &quot;&quot;,
      start: getCurrentDateTime(),
      end: getOneHourFromNow(),
      color: DEFAULT_EVENT_COLOR,
      categoryName: DEFAULT_CATEGORY_NAME,
    };
  }

  return {
    events,
    setEvents,
    isSubmitting,
    errors,
    setErrors,
    handleFormSubmit,
    handleSelectEvent,
    handleDeleteEvent,
    handleSelectSlot,
    getInitialFormState,
  };
}

</code>
</pre>
<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
